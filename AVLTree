#include<sstream>

#include<algorithm>

#include<iostream>

using namespace std;

// structure data type called 'AVLT' used to group the members of data, left, and right
struct AVLT {
    int data;
    struct AVLT * left;
    struct AVLT * right;
};

AVLT * tree;

class AVLTree {
public:
    // Constructor
    AVLTree() {
        tree -> data = -1;
        tree -> left = NULL;
        tree -> right = NULL;
    }

    // AVLTree Attributes
    int getHeight(AVLT * );
    int getBalanceFactor(AVLT * );

    AVLT * balanceTree(AVLT * );
    // Insert Node
    AVLT * insertNode(AVLT * , int);
    // Delete Node
    AVLT * deleteNode(AVLT * , int, int depth = 1);
    // Find In-Order Successor
    AVLT * inOrderSuccessor(AVLT * );
    // Display Values
    void show(AVLT * , int);

    // Tree Traversals
    void inOrderTraversal(AVLT * );
    void preOrderTraversal(AVLT * );
    void postOrderTraversal(AVLT * );

    // Tree Rotations
    AVLT * rightRightRotation(AVLT * );
    AVLT * leftLeftRotation(AVLT * );
    AVLT * leftRightRotation(AVLT * );
    AVLT * rightLeftRotation(AVLT * );
};

// return height of tree
int AVLTree::getHeight(AVLT * tree) {
    int treeHeight = 0;
    if (tree != NULL) {
        int leftTreeHeight = getHeight(tree -> left);
        int rightTreeHeight = getHeight(tree -> right);
        int maxTreeHeight = max(leftTreeHeight, rightTreeHeight);
        treeHeight = maxTreeHeight + 1;
    }
    return treeHeight;
}

// return balance factor of tree
int AVLTree::getBalanceFactor(AVLT * tree) {
    int leftTreeHeight = getHeight(tree -> left);
    int rightTreeHeight = getHeight(tree -> right);
    int balanceFactor = leftTreeHeight - rightTreeHeight;
    return balanceFactor;
}

AVLT * AVLTree::rightRightRotation(AVLT * parent) {
    AVLT * tree;
    tree = parent -> right;
    parent -> right = tree -> left;
    tree -> left = parent;
    return tree;
}
AVLT * AVLTree::leftLeftRotation(AVLT * parent) {
    AVLT * tree;
    tree = parent -> left;
    parent -> left = tree -> right;
    tree -> right = parent;
    return tree;
}
AVLT * AVLTree::leftRightRotation(AVLT * parent) {
    AVLT * t;
    t = parent -> left;
    parent -> left = rightRightRotation(t);
    return leftLeftRotation(parent);
}
AVLT * AVLTree::rightLeftRotation(AVLT * parent) {
    AVLT * tree;
    tree = parent -> right;
    parent -> right = leftLeftRotation(tree);
    return rightRightRotation(parent);
}
AVLT * AVLTree::balanceTree(AVLT * tree) {
    int balanceFactor = getBalanceFactor(tree);
    if (balanceFactor > 1) {
        if (getBalanceFactor(tree -> left) > 0)
            tree = leftLeftRotation(tree);
        else
            tree = leftRightRotation(tree);
    } else if (balanceFactor < -1) {
        if (getBalanceFactor(tree -> right) > 0) {
            tree = rightLeftRotation(tree);
        } else {
            tree = rightRightRotation(tree);
        };
    }
    return tree;
}

AVLT * AVLTree::insertNode(AVLT * treeNode, int v) {
    if (treeNode == NULL) {
        treeNode = new AVLT;
        treeNode -> data = v;
        treeNode -> left = NULL;
        treeNode -> right = NULL;
        return treeNode;
    } else if (v < treeNode -> data) {
        treeNode -> left = insertNode(treeNode -> left, v);
        treeNode = balanceTree(treeNode);
    } else if (v >= treeNode -> data) {
        treeNode -> right = insertNode(treeNode -> right, v);
        treeNode = balanceTree(treeNode);
    }
    return treeNode;
}

AVLT * AVLTree::inOrderSuccessor(AVLT * treeNode) {
    AVLT * parentNode;
    while (treeNode -> left != NULL) {
        parentNode = treeNode;
        treeNode = treeNode -> left;
    }
    if (treeNode -> right == NULL) {
        parentNode -> left = NULL;
        return treeNode;
    } else {
        parentNode -> left = treeNode -> right;
        return treeNode;
    }
}

AVLT * AVLTree::deleteNode(AVLT * treeNode, int v, int depth) {
    if (treeNode == NULL) {
        cout << "Value not found in tree";
    } else if (v < treeNode -> data) {
        treeNode -> left = deleteNode(treeNode -> left, v, depth + 1);
    } else if (v > treeNode -> data) {
        treeNode -> right = deleteNode(treeNode -> right, v, depth + 1);
    } else if (treeNode -> left && treeNode -> right) {
        treeNode = inOrderSuccessor(treeNode -> right);
    } else if (treeNode -> left == NULL && treeNode -> right == NULL) {
        treeNode = NULL;
    } else if (treeNode -> left != NULL) {
        treeNode = treeNode -> left;
    } else {
        treeNode = treeNode -> right;
    }
    if (depth == 1) {
        treeNode = balanceTree(treeNode);
    }
    return treeNode;
}

// The following traversal methods are recursive
void AVLTree::inOrderTraversal(AVLT * tree) {
    if (tree == NULL) {
        return;
    }
    inOrderTraversal(tree -> left);
    cout << tree -> data << " ";
    inOrderTraversal(tree -> right);
}
void AVLTree::preOrderTraversal(AVLT * tree) {
    if (tree == NULL) {
        return;
    }
    cout << tree -> data << " ";
    preOrderTraversal(tree -> left);
    preOrderTraversal(tree -> right);
}
void AVLTree::postOrderTraversal(AVLT * tree) {
    if (tree == NULL) {
        return;
    }
    postOrderTraversal(tree -> left);
    postOrderTraversal(tree -> right);
    cout << tree -> data << " ";
}
